#!/usr/bin/env ruby
# frozen_string_literal: true

#
# This file was generated by Bundler then edited by me.
#
# The application 'bundle' is installed as part of a gem, and
# this file is here to facilitate running it.
#

require 'rubygems'

# Monkey patch to avoid active support for lone String#present? call below.
module Presentable
  def present? = !empty?
end

# Monkey patch to avoid active support for lone String#present? call below.
class Array
  include Presentable
end

# Monkey patch to avoid active support for lone String#present? call below.
class String
  include Presentable
end

# Monkey patch to avoid active support for lone String#present? call below.
class NilClass
  def present? = false
end

m = Module.new do
  module_function

  # :reek:UtilityFunction
  def invoked_as_script?
    File.expand_path($PROGRAM_NAME) == File.expand_path(__FILE__)
  end

  # :reek:UtilityFunction
  def env_var_version = ENV.fetch('BUNDLER_VERSION', nil)

  def cli_arg_version
    return unless invoked_as_script?
    return unless 'update'.start_with?(ARGV.first || ' ')

    bundler_version = nil
    winner = false
    ARGV.each do |arg|
      bundler_version = arg if winner && arg.match(anchored_version_pattern)

      next unless arg =~ /\A--bundler(?:[= ](#{version_pattern}))?\z/o

      bundler_version = Regexp.last_match(1)
      winner = true
    end

    bundler_version
  end

  def anchored_version_pattern = Gem::Version::ANCHORED_VERSION_PATTERN
  def version_pattern = Gem::Version::VERSION_PATTERN

  def gemfile
    gemfile = ENV.fetch('BUNDLE_GEMFILE', nil)
    return gemfile if gemfile.present?

    File.expand_path('../Gemfile', __dir__)
  end

  def lockfile
    lockfile =
      case File.basename(gemfile)
      when 'gems.rb' then gemfile.sub(/\.rb$/, gemfile)
      else "#{gemfile}.lock"
      end
    File.expand_path(lockfile)
  end

  def lockfile_version
    return unless File.file?(lockfile)

    lockfile_contents = File.read(lockfile)
    return unless lockfile_contents.match(lockfile_contents_regex)

    Regexp.last_match(1)
  end

  def bundler_requirement
    @bundler_requirement ||=
      env_var_version ||
      cli_arg_version ||
      bundler_requirement_for(lockfile_version)
  end

  # :reek:UtilityFunction
  def bundler_requirement_for(version)
    return "#{Gem::Requirement.default}.a" unless version

    bundler_gem_version = Gem::Version.new(version)
    bundler_gem_version.approximate_recommendation
  end

  def load_bundler!
    ENV['BUNDLE_GEMFILE'] ||= gemfile
    activate_bundler
  end

  def lockfile_contents_regex
    /\n\nBUNDLED WITH\n\s{2,}(#{Gem::Version::VERSION_PATTERN})\n/o
  end

  def activate_bundler
    gem_error = activation_error_handling do
      gem 'bundler', bundler_requirement
    end

    return unless gem_error

    require_failed = !activation_error_handling do
      require 'bundler/version'
    end

    if require_failed && Gem::Requirement.new(
      bundler_requirement
    ).satisfied_by?(
      Gem::Version.new(
        Bundler::VERSION
      )
    )
      return
    end

    warn [
      "Activating bundler (#{bundler_requirement}) failed:",
      gem_error.message,
      '',
      'To install the version of bundler this project requires, run:',
      "  `gem install bundler -v '#{bundler_requirement}`",
    ].join("\n")

    exit 42
  end

  def activation_error_handling
    yield
    nil
  rescue StandardError, LoadError => e
    e
  end
end

m.load_bundler!

load Gem.bin_path('bundler', 'bundle') if m.invoked_as_script?
